/* 
Найти точку пересечения двух прямых заданных уравнением 
y = (k1 * x) + b1, y = (k2 * x) + b2, | b1 k1 и b2 и k2 заданы 

1) Задать значения  b1, b2, k1, k2
2) Задать двумерный массив, наполненный числами, которые иллюстрируют положение точек x и y, которые получены в результате подставления вместо x произвольного числа

*/

/* присвоение переменным целочисленных значений (как указано в условии)

double k1 = 7;
double k2 = 5;
double b1 = 4; // y = 7x + 4 || x = 0, y = 4; x = 1, y = 11; x = 2, y = 18; и так далее
double b2 = 10; // y = 5x + 10 || x = 0, y = 10; x = 1, y = 15; x = 2, y = 20; и так далее
Console.WriteLine("Введите значение множителя x для указанных прямых (целое или вещественное число): ");
double x = Convert.ToDouble(Console.ReadLine());

*/

int[,] firstStraightLineOnTheScreen = new int[,] // массив построен на основе функции первой прямой y = 7x + 4. Единицей обозначены те элементы, которые на графике функции иллюстрируют пересечение абсциссы и ординаты этой прямой: так, элемент [0, 4] означает, что при x = 0 y будет равен 4, если подставить эти значения в функцию. Все остальные элементы этого массива и массива ниже построены по такому же принципу.
{
    { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [0, 0] [0, 1] [0, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [1, 0] [1, 1] [1, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [2, 0] [2, 1] [2, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [3, 0] [3, 1] [3, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [4, 0] [4, 1] [4, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 }, // [5, 0] [5, 1] [5, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [6, 0] [6, 1] [6, 2]
}; // 0 - условное обозначение пикселя, который не нужно закрашивать; 1 - условное обозначение пикселя, который нужно закрасить

int[,] secondStraightLineOnTheScreen = new int[,] // 0 - условное обозначение пикселя, который не нужно закрашивать; 1 - условное обозначение пикселя, который нужно закрасить
{
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [0, 0] [0, 1] [0, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [1, 0] [1, 1] [1, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [2, 0] [2, 1] [2, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [3, 0] [3, 1] [3, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // [4, 0] [4, 1] [4, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 }, // [5, 0] [5, 1] [5, 2]...
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 }, // [6, 0] [6, 1] [6, 2]
};

void PrintStraigthLines(int[,] testArray) // метод, проставляющий знак плюса в точке пересечения абсцисс и ординат
{
    for (int i = 0; i < testArray.GetLength(0); i++)
    {
        for (int j = 0; j < testArray.GetLength(1); j++)
        {
            if (testArray[i, j] == 0) Console.Write(" ");
            else Console.Write("+");
        }
        Console.WriteLine(); // пустая строка для корректного отображения строк
    }
}

void dotsIntersection(int[,] firstArr, int[,] secondArr) // метод, выводящий на экран конкретную точку пересечения двух прямых. Суть метода - перебор всех элементов первого и второго массивов для нахождения абсолютно аналогичных по значению элементов (не равных нулю) и обязательно расположенных на одной и той же позиции по индексу (ключевая деталь в алгоритме поиска нужного элемента).
{
    Console.WriteLine();
    for (int i = 0; i < firstArr.GetLength(0); i++)
    {
        for (int j = 0; j < firstArr.GetLength(1); j++)
        {
            for (int x = 0; x < secondArr.GetLength(0); x++)
            {
                for (int z = 0; z < secondArr.GetLength(1); z++)
                {
                    if (i == x && j == z && firstArr[i, j] == secondArr[x, z] && firstArr[i, j] != 0 && secondArr[x, z] != 0) Console.WriteLine($"Точка пересечения двух прямых находится на {i} строке {j} столбца обоих массивов");
                }
            }
        }
    }
}

PrintStraigthLines(firstStraightLineOnTheScreen);
PrintStraigthLines(secondStraightLineOnTheScreen);
dotsIntersection(firstStraightLineOnTheScreen, secondStraightLineOnTheScreen); // немного зубодробительный алгоритм, но главное, что он работает :D